<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>JavaScript</title><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script></head><body><nav class="main-nav"><a href="/">Home</a><a href="/archives">Archives</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/about"><img class="2x" id="avatar" src="/images/avatar.png"></a><h1>ヾ(❀╹◡╹)~Hi</h1><h2></h2></header></section></div><section class="post" id="wrapper"><article><header><h1>JavaScript</h1><h2 class="headline">Jun 21, 2019 3:47·7.6k words
·30 minutes read<span class="tags"></span></h2></header><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#♔JavaScript"><span class="toc-text">♔JavaScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#♕快速入口"><span class="toc-text">♕快速入口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本语法"><span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-语法"><span class="toc-text">&gt;语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-大小写"><span class="toc-text">&gt;大小写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#♖数据类型和变量"><span class="toc-text">♖数据类型和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#布尔值"><span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map和Set"><span class="toc-text">Map和Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#♘iterable"><span class="toc-text">♘iterable</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象"><span class="toc-text">抽象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数定义和调用"><span class="toc-text">函数定义和调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义函数"><span class="toc-text">定义函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量作用域与解构赋值"><span class="toc-text">变量作用域与解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#变量提升"><span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局作用域"><span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#函数作为返回值"><span class="toc-text">函数作为返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标准对象"><span class="toc-text">标准对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#包装对象"><span class="toc-text">包装对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegExp"><span class="toc-text">RegExp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象编程"><span class="toc-text">面向对象编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浏览器"><span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AJAX"><span class="toc-text">AJAX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas"><span class="toc-text">Canvas</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#理解坐标"><span class="toc-text">理解坐标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#绘制形状"><span class="toc-text">绘制形状</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#绘制文本"><span class="toc-text">绘制文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#练习Canvas"><span class="toc-text">练习Canvas</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#线条"><span class="toc-text">线条</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#圆形"><span class="toc-text">圆形</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#渐变"><span class="toc-text">渐变</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JQuery"><span class="toc-text">JQuery</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#版本"><span class="toc-text">版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择器"><span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#层级选择器"><span class="toc-text">层级选择器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-text">事件</span></a></li></ol></li></div><section id="post-body"><h1 id="♔JavaScript"><a href="#♔JavaScript" class="headerlink" title="♔JavaScript"></a>♔JavaScript</h1><p>JavaScript的诞生<del>~</del></p>
<p>这要追溯到上个世纪90年代末(1995)，当时网景公司正凭借着超高的技术Navigator浏览器才成为Web新时代的开端是那时最著名的第一代互联网公司<span style="color:#FF4040">ヽ(✿ﾟ▽ﾟ)ノ</span>&gt;友情提示:JAVA是97年出生的.</p>
<p>由于网景公司希望可以在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这帮兄弟们<span style="color:#FF4040">(๑•̀ㅂ•́)و✧</span>在两周之内设计出了JavaScript语言。没错！你没有看错，这帮兄弟只用了10天！10天呐！兄弟们，仅仅10天时间他们就创造了JavaScript。至于为什么起名叫JavaScript？原因是因为当时Java那只小憋蛙特别红火，所以网景公司希望借着Java的名气来推广自己的孩子,但事实上JavaScript除了语法上有点像，其他部分其实没啥关系，所以千万不要以为它们是双胞胎︿(￣︶￣)︿</p>
<h1 id="♕快速入口"><a href="#♕快速入口" class="headerlink" title="♕快速入口"></a>♕快速入口</h1><p>JavaScript代码可以直接镶嵌在网页的任何地方，大部分人通常把JavaScript放在<code>&lt;head&gt;</code>中，个人喜欢他在<code>&lt;body&gt;</code>里:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    alert('Hello, world');</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="gt-语法"><a href="#gt-语法" class="headerlink" title="&gt;语法"></a>&gt;语法</h4><p>前面已经说过JavaScript和Java语法类似，每个语句以’<span style="color:red">;</span>‘结束，语句块用<span style="color:red">{…}</span>。但是JavaScript不强求，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上。</p>
<p>知道判断语句的都知道，如果判断成立，它会执行<span style="color:red">{…}</span>中的所有语句:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (2 &gt; 1) &#123;</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">    z = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">{…}</span>还可以嵌套，明白就好朕就不写了(ー`´ー)</p>
<p>接下来我们讲讲 <span style="font-size:20px">注释</span> 的高逼格用法: </p>
<p><span style="color:red">//</span>:这个是单行注释，下面的是栗子(￣～￣) 嚼！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一行注释</span></span><br><span class="line">alert(<span class="string">'Hello'</span>);		<span class="comment">//我是注释</span></span><br></pre></td></tr></table></figure>

<p><span style="color:red">/<em>*…</em>/</span>这是多行注释:(ps:另一个*被消掉了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*	第一行</span></span><br><span class="line"><span class="comment">	第二行	</span></span><br><span class="line"><span class="comment">	第三行*/</span></span><br></pre></td></tr></table></figure>

<h4 id="gt-大小写"><a href="#gt-大小写" class="headerlink" title="&gt;大小写"></a>&gt;大小写</h4><p>请注意~请注意！</p>
<p>JavaScript是严格区分大小写，如果一不小心搞错了，你放心程序会用☢报错的方式提醒你或者运行不正常。</p>
<h3 id="♖数据类型和变量"><a href="#♖数据类型和变量" class="headerlink" title="♖数据类型和变量"></a>♖数据类型和变量</h3><p>爸爸来介绍几中数据类型:</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Number : 英语懂吧，不懂就有道翻译。JavaScript和Java不一样它不区分整数和浮点数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>;		<span class="comment">//这是整数</span></span><br><span class="line"><span class="number">0.456</span>;		<span class="comment">//这是浮点数</span></span><br><span class="line"><span class="number">1.2345e3</span>;	<span class="comment">//这是啥</span></span><br><span class="line">-<span class="number">99</span>;		<span class="comment">//这是负数</span></span><br></pre></td></tr></table></figure>

<p>  <span style="color:red">/</span>：这是求除数         <span style="color:red">%</span>：这是求余数    10/3=3 这是栗子     /=3 ；% = 1 这是结果前者是除数 后者是余数</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串使用单引号或双引号括起来的文本，比如  <span style="color:red">‘abc’</span>,  <span style="color:red">“abb”</span>等。</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>它是一个判断值，它只有 <span style="color:red">true</span>、<span style="color:red">false</span>两种值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>;	<span class="comment">//这是true</span></span><br><span class="line"><span class="number">2</span> &lt; <span class="number">1</span>;	<span class="comment">//这是false</span></span><br></pre></td></tr></table></figure>

<p>  <span style="color:red">&amp;&amp;、||、!</span> 这是与、或、非</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">true</span> &amp;&amp; <span class="keyword">true</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为true</span></span><br><span class="line"><span class="keyword">true</span> &amp;&amp; <span class="keyword">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></span><br><span class="line"><span class="keyword">false</span> &amp;&amp; <span class="keyword">true</span> &amp;&amp; <span class="keyword">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></span><br><span class="line"><span class="keyword">false</span> || <span class="keyword">false</span>; <span class="comment">// 这个||语句计算结果为false</span></span><br><span class="line"><span class="keyword">true</span> || <span class="keyword">false</span>; <span class="comment">// 这个||语句计算结果为true</span></span><br><span class="line"><span class="keyword">false</span> || <span class="keyword">true</span> || <span class="keyword">false</span>; <span class="comment">// 这个||语句计算结果为true</span></span><br><span class="line">  ! <span class="keyword">true</span>; <span class="comment">// 结果为false</span></span><br><span class="line">! <span class="keyword">false</span>; <span class="comment">// 结果为true</span></span><br><span class="line">! (<span class="number">2</span> &gt; <span class="number">5</span>); <span class="comment">// 结果为true</span></span><br></pre></td></tr></table></figure>

<h4 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h4><p>JavaScript的默认表示方式{}可以视为其他语言中的Map和Dictionary的数据结构，即一组键值对。</p>
<p><span style="font-size:20px">Map</span></p>
<p><span style="color:red">Map</span>是一组键值对的结构，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure>

<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Map([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>

<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Map(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Map();</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>

<p><span style="font-size:20px">Set</span></p>
<p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key。</p>
<p>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Set(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>

<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="♘iterable"><a href="#♘iterable" class="headerlink" title="♘iterable"></a><span style="font-size:30px">♘</span>iterable</h4><p>遍历<span style="color:red">Array</span>可以采用下标循环，遍历<span style="color:red">Map</span>和<span style="color:red">Set</span>就无法使用下标。为了统一集合国度，ES6标准引入了新的<span style="color:red">iterable</span>类型，而那三个<span style="color:red">红字</span>的都是<span style="color:red">(☄⊙ω⊙)☄ iterable</span>的弟弟。</p>
<p>用<span style="color:red">for. . . of</span>循环遍历集合，用法<span style="font-size:45px;color:#8A2BE2">☟</span>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">alert(x);	<span class="comment">//A,B,C</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123;</span><br><span class="line">alert(x);	<span class="comment">//A,B,C</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123;</span><br><span class="line">alert(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]); </span><br><span class="line">&#125;	<span class="comment">//m1=x,m2=y,m3=z</span></span><br></pre></td></tr></table></figure>

<p><span style="color:red">for. . . of</span>和<span style="color:red">for. . . in</span>的区别？_(:驴」∠)_爸爸也母鸡啊~</p>
<p>好！在经历一番搜查后，爸爸终于知道它们的区别～(￣▽￣～)(～￣▽￣)～</p>
<p>废话少说！上图</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">in</span> a)&#123;</span><br><span class="line">    alert(x);		<span class="comment">// 0，1，2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你们看我用了<span style="color:red">Array</span>集合，使用<span style="color:red">for. . . in</span>循环方式，结果呢？显而易见它就是下标(๑•̀ㅂ•́)و✧</p>
<p>当我们使用<span style="color:red">for. . . of</span>的时候呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> a)&#123;</span><br><span class="line">    alert(x);	<span class="comment">// A,B,C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当当当~它就是值。</p>
<p>再用它们去循环<span style="color:red">Map</span>和<span style="color:red">Set</span>试试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]); </span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="number">1</span>,<span class="string">'x'</span>],[<span class="number">2</span>,<span class="string">'y'</span>],[<span class="number">3</span>,<span class="string">'z'</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">    alert(x);  <span class="comment">//A,B,C</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> m)&#123;</span><br><span class="line">    alert(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);	<span class="comment">//m1=x,m2=y,m3=z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>圆的面积计算公式:</p>
<p>S = πr</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>抽象是数学中非常常见的概念。</p>
<p>计算数列的和，比如：<span style="color:red"><code>1 + 2 + 3 + ... + 100</code></span>，写起来十分不方便，于是数学家发明了求和符号∑，可以把<span style="color:red"><code>1 + 2 + 3 + ... + 100</code>&lt;/记作：</span></p>
<p>100</p>
<p>∑n</p>
<p>n=1 </p>
<p>这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。</p>
<p>而且，这种抽象记法是可扩展的，比如：</p>
<p>100</p>
<p>∑(n2+1) </p>
<p>n=1</p>
<p>还原成加法运算就变成了：</p>
<p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)</p>
<p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
<h3 id="函数定义和调用"><a href="#函数定义和调用" class="headerlink" title="函数定义和调用"></a>函数定义和调用</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>在JavaScript中，定义函数的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述<span style="color:red"><code>abs()</code></span>函数的定义如下：</p>
<ul>
<li><span style="color:red"><code>function</code></span>指出这是一个函数定义；</li>
<li><span style="color:red"><code>abs</code></span>是函数的名称；</li>
<li><span style="color:red"><code>(x)</code></span>括号内列出函数的参数，多个参数以<span style="color:red"><code>,</code></span>分隔；</li>
<li><span style="color:red"><code>{ ... }</code></span>之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。</li>
</ul>
<h3 id="变量作用域与解构赋值"><a href="#变量作用域与解构赋值" class="headerlink" title="变量作用域与解构赋值"></a>变量作用域与解构赋值</h3><p>JavaScript中。用<span style="color:red"><code>var</code></span>申明的变量实际上是有作用域的。</p>
<p>如果一个变量在函数体内内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = x + <span class="number">2</span>; <span class="comment">// ReferenceError! 无法在函数体外引用变量x</span></span><br></pre></td></tr></table></figure>

<p>如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'A'</span>;</span><br><span class="line">    x = x + <span class="string">'B'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = x + <span class="number">1</span>; <span class="comment">// bar可以访问foo的变量x!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> z = y + <span class="number">1</span>; <span class="comment">// ReferenceError! foo不可以访问bar的变量y!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>虽然是strict模式，但语句<span style="color:red"><code>var x = &#39;Hello, &#39; + y;</code></span>并不报错，原因是变量<code>y</code>在稍后申明了。但是<span style="color:red"><code>console.log</code></span>显示<span style="color:red"><code>Hello, undefined</code></span>，说明变量<code>y</code>的值为<span style="color:red"><code>undefined</code></span>。这正是因为JavaScript引擎自动提升了变量<span style="color:red"><code>y</code></span>的声明，但不会提升变量<span style="color:red"><code>y</code></span>的赋值。</p>
<p>对于上述<span style="color:red"><code>foo()</code></span>函数，JavaScript引擎看到的代码相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y; <span class="comment">// 提升变量y的申明，此时y为undefined</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    y = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个<span style="color:red"><code>var</code></span>申明函数内部用到的所有变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></span><br><span class="line">        y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></span><br><span class="line">        z, i; <span class="comment">// z和i为undefined</span></span><br><span class="line">    <span class="comment">// 其他语句:</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>不在任何函数内定义的变量就是具有全局作用域。实际上，JavaScript默认一个全局对象<span style="color:red"><code>window</code></span>,全局作用域的变量实际上被绑定到<span style="color:red"><code>window</code></span>的一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> course = <span class="string">'Learn JavaScript'</span>;</span><br><span class="line">alert(course); <span class="comment">// 'Learn JavaScript'</span></span><br><span class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// 'Learn JavaScript'</span></span><br></pre></td></tr></table></figure>

<p>因此，直接访问全局变量<span style="color:red"><code>course</code></span>和访问<span style="color:red"><code>window.course</code></span>是完全一样的。</p>
<p>你可能猜到了，由于函数定义有两种方式，以变量方式<span style="color:red"><code>var foo = function () {}</code></span>定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到<span style="color:red"><code>window</code></span>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 直接调用foo()</span></span><br><span class="line"><span class="built_in">window</span>.foo(); <span class="comment">// 通过window.foo()调用</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>在一个对象中绑定函数，称为这个对象的方法。</p>
<p>在JavaScript中，对象的定义是这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name:<span class="string">'小明'</span>,</span><br><span class="line">    birth:<span class="number">1990</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，如果我们给<span style="color:red"><code>xiaoming</code></span>绑定一个函数，就可以做更多的事情。比如，写个<span style="color:red"><code>age()</code></span>方法，返回<span style="color:red"><code>xiaoming</code></span>的年龄：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age; <span class="comment">// function xiaoming.age()</span></span><br><span class="line">xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></span><br></pre></td></tr></table></figure>

<p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个<span style="color:red"><code>this</code></span>关键字，这个东东是什么？</p>
<p>在一个方法内部，<span style="color:red"><code>this</code></span>是一个特殊变量，它始终指向当前对象，也就是<span style="color:red"><code>xiaoming</code></span>这个变量。所以，<span style="color:red"><code>this.birth</code></span>可以拿到<span style="color:red"><code>xiaoming</code></span>的<span style="color:red"><code>birth</code></span>属性。</p>
<p>让我们拆开写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>单独调用函数<span style="color:red"><code>getAge()</code></span>怎么返回了<span style="color:red"><code>NaN</code></span>？<em>请注意</em>，我们已经进入到了JavaScript的一个大坑里。</p>
<p>JavaScript的函数内部如果调用了<span style="color:red"><code>this</code></span>，那么这个<span style="color:red"><code>this</code></span>到底指向谁？</p>
<p>答案是，视情况而定！</p>
<p>如果以对象的方法形式调用，比如<span style="color:red"><code>xiaoming.age()</code></span>，该函数的<span style="color:red"><code>this</code></span>指向被调用的对象，也就是<span style="color:red"><code>xiaoming</code></span>，这是符合我们预期的。</p>
<p>如果单独调用函数，比如<span style="color:red"><code>getAge()</code></span>，此时，该函数的<span style="color:red"><code>this</code></span>指向全局对象，也就是<span style="color:red"><code>window</code></span>。</p>
<p>坑爹啊！</p>
<p>更坑爹的是，如果这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line">fn(); <span class="comment">// NaN1</span></span><br></pre></td></tr></table></figure>

<p>也是不行的！要保证<span style="color:red"><code>this</code></span>指向正确，必须用<span style="color:red"><code>obj.xxx()</code></span>的形式调用！</p>
<p>由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的<span style="color:red"><code>this</code></span>指向<span style="color:red"><code>undefined</code></span>，因此，在strict模式下，你会得到一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = xiaoming.age;</span><br><span class="line">fn(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></span><br></pre></td></tr></table></figure>

<p>这个决定只是让错误及时暴露出来，并没有解决<span style="color:red"><code>this</code></span>应该指向的正确位置。</p>
<p>有些时候，喜欢重构的你把方法重构了一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></span><br></pre></td></tr></table></figure>

<p>结果又报错了！原因是<span style="color:red"><code>this</code></span>指针只在<span style="color:red"><code>age</code></span>方法的函数内指向<span style="color:red"><code>xiaoming</code></span>，在函数内部定义的函数，<span style="color:red"><code>this</code></span>又指向<span style="color:red"><code>undefined</code></span>了！（在非strict模式下，它重新指向全局对象<span style="color:red"><code>window</code></span>！）</p>
<p>修复的办法也不是没有，我们用一个<span style="color:red"><code>that</code></span>变量首先捕获<span style="color:red"><code>this</code></span>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>用<span style="color:red"><code>var that = this;</code></span>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>我们来实现一个对<span style="color:red"><code>Array</code></span>的求和，通常情况下，求和的函数是这样定义的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><p>在JavaScript的世界里，一切都是对象。</p>
<p>但是某些对象还是和其他对象不太一样，为了区分对象的类型，我们用<span style="color:red"><code>typeof</code></span>操作获取对象的类型，它总是返回一个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'str'</span>; <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// 'object</span></span><br></pre></td></tr></table></figure>

<p>可见，<span style="color:red"><code>number</code></span>、<span style="color:red"><code>string</code></span>、<span style="color:red"><code>boolean</code></span>、<span style="color:red"><code>function</code></span>和<span style="color:red"><code>undefined</code></span>有别于其他类型。特别注意<span style="color:red"><code>null</code></span>的类型是<span style="color:red"><code>object</code></span>，<span style="color:red"><code>Array</code></span>的类型也是<span style="color:red"><code>object</code></span>，如果我们用<span style="color:red"><code>typeof</code></span>将无法区分出<span style="color:red"><code>null</code></span>、<span style="color:red"><code>Array</code></span>和通常意义上的object——<span style="color:red"><code>{}</code></span>。</p>
<h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚<span style="color:red"><code>int</code></span>和<span style="color:red"><code>Integer</code></span>这种暧昧关系。</p>
<p><span style="color:red"><code>number</code></span>、<span style="color:red"><code>boolean</code></span>和<span style="color:red"><code>string</code></span>都有包装对象。没错，在JavaScript中，字符串也区分<span style="color:red"><code>string</code></span>类型和它的包装类型。包装对象用<span style="color:red"><code>new</code></span>创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'str',生成了新的包装类型</span></span><br></pre></td></tr></table></figure>

<p>虽然包装对象看上去和原来的值一模一样，显示出来也是一样，但他们的类型已经变为<span style="color:red"><code>object</code></span>了！所以，包装对象和原始值用<span style="color:red"><code>===</code></span>比较会返回<span style="color:red"><code>false</code></span>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>所以<span style="color:red"><em>闲的蛋疼也不要使用包装对象</em></span>！尤其是针对<span style="color:red"><code>string</code></span>类型！！！</p>
<p>如果我们在使用<span style="color:red"><code>Number</code></span>、<span style="color:red"><code>Boolean</code></span>和<span style="color:red"><code>String</code></span>时，没有写<span style="color:red"><code>new</code></span>会发生什么情况？</p>
<p>此时，<span style="color:red"><code>Number()</code></span>、<span style="color:red"><code>Boolean</code></span>和<span style="color:red"><code>String()</code></span>被当做普通函数，把任何类型的数据转换为<span style="color:red"><code>number</code></span>、<span style="color:red"><code>boolean</code></span>和<span style="color:red"><code>string</code></span>类型（注意不是其包装类型）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="string">'123'</span>); <span class="comment">// 123，相当于parseInt()或parseFloat()</span></span><br><span class="line"><span class="keyword">typeof</span> n; <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Boolean</span>(<span class="string">'true'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// 'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">'false'</span>); <span class="comment">// true! 'false'字符串转换结果为true！因为它是非空字符串！</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">String</span>(<span class="number">123.45</span>); <span class="comment">// '123.45'</span></span><br><span class="line"><span class="keyword">typeof</span> s; <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure>

<p>总结一下，有这么几条规则需要遵守：</p>
<ul>
<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>
<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>
<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>
<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>
<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>
<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>
<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>
<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>
<li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li>
</ul>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><span style="color:red"><code>Date</code></span>对象用来表示日期和时间。</p>
<p>要获取系统当前时间，用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2019 10:48:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2019, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 3, 月份，注意月份范围是0~11，3表示四月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 10, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 48, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure>

<p>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。</p>
<p>如果要创建一个指定日期和时间的<code>Date</code>对象，可以用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2019, 3, 10, 50, 15, 30, 123);</span><br><span class="line">d; // Fri Jun 19 2019 10:50:30 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>

<p>你可能观察到了一个<em>非常非常坑爹</em>的地方，就是JavaScript的月份范围用整数表示是0~11，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示4月，我们传入的是`3！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。</p>
<p> JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 </p>
<p>第二种创建一个指定日期和时间的方法是解析一个符合<a href="http://www.w3.org/TR/NOTE-datetime" target="_blank" rel="noopener">ISO 8601</a>格式的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = Date.parse(&apos;2015-06-24T19:49:22.875+08:00&apos;);</span><br><span class="line">d; // 1435146562875</span><br></pre></td></tr></table></figure>

<p>但它返回的不是<code>Date</code>对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(1435146562875);</span><br><span class="line">d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span><br><span class="line">d.getMonth(); // 5</span><br></pre></td></tr></table></figure>

<p> 使用Date.parse()时传入的字符串使用实际月份01<del>12，转换为Date对象后getMonth()获取的月份值为0</del>11。 </p>
<h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>知道这是什么吗？没错！他是正则表达式~~</p>
<p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用异种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<p>所以我判断一个字符串是否是合法的Email的方法是：</p>
<p>1.创建一个匹配Email的正则表达式；</p>
<p>2.用该正则表达式去匹配用户的输入来判断是否合法。</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>JavaScript的所有数据都可以看成对象，但是他不是说已经在使用面向对象编程。</p>
<p>如果只是使用<code>Number</code>、<code>Array</code>、<code>string</code>以及基本的<code>{...}</code>定义的对象，还无法发挥出面向对象编程的威力。</p>
<p>JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都太一样，如果你熟悉Java或C#，很好，你一定明白面向对象的两个基本概念：</p>
<p>1.类:类是对象的类型模板，列如:定义<code>Student</code>类来表示学生，类本身是一种类型，<code>Student</code>表示学生类型，但不表示任何具体的某个学生；</p>
<p>2.实例：实例是根据类创建的对象，列如，根据<code>Student</code>类可以创建出<code>xiaoming</code>、<code>xiaohong</code>、<code>xiaojun</code>等多个实例，每个实例表示一个具体的学生，他们全都属于<code>Student</code>类型。</p>
<p><span style="color:blue"><code>类是对象的抽象，对象是类的实例</code></span></p>
<p>在JavaScript是不区分类和实例，而是通过原型(prototype)来实现面向对象编程。</p>
<p>原型是指当我们想要创建<code>xiaoming</code>这个具体的学生时，我们并没有一个<code>Student</code>类型可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> robot = &#123;</span><br><span class="line">    name:<span class="string">'Robot'</span>,</span><br><span class="line">    height:<span class="number">1.6</span>,</span><br><span class="line">    run:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name + <span class="string">'is running...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看这个<code>robot</code>对象名字，有身高，还会跑，还会哇哇叫，有点像小明，干脆就叫小明！！！</p>
<p>于是我们把它改为<code>Student</code>，然后创建出xiaoming:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。</p>
<p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p>
<p>这就是Web的运作原理：<strong>一次HTTP请求对应一个页面。</strong></p>
<p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断的更新。</p>
<p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p>
<p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>在JavaScript的世界中，所有代码都是单线程执行的。</p>
<p>由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before setTimeout()'</span>);</span><br><span class="line">setTimeout(callback, <span class="number">1000</span>); <span class="comment">// 1秒钟后调用callback函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after setTimeout()'</span>);</span><br></pre></td></tr></table></figure>

<p>AJAX就是典型的异步操作。以上一节的代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把回调函数<span style="color:red"><code>success(request.responseText)</code></span>和<span style="color:red"><code>fail(request.status)</code></span>写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。</p>
<p>有没有更好的写法？比如写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = ajaxGet(<span class="string">'http://...'</span>);</span><br><span class="line">ajax.ifSuccess(success)</span><br><span class="line">    .ifFail(fail);</span><br></pre></td></tr></table></figure>

<p>这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用<span style="color:red"><code>success</code></span>函数或<span style="color:red"><code>fail</code></span>函数。</p>
<p>古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。</p>
<p>Promise有一下几种状态：</p>
<ul>
<li>pending：初始状态，即不是成功，也不是失败状态</li>
<li>fulfilled：意味着操作成功完成。</li>
<li>rejected：意味着操作失败。</li>
</ul>
<p>pending状态的Promise对象可能触发fulfilled状态并传递一个值给相应的状态处理方法，也可能触发失败状态(rejected)并传递失败信息。当其中任一种情况出现时，Promise对象的then方法绑定的处理方法（hendlers）就会被调用。</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas是HTML5新增的组件，它就像是一块幕布，可以用JavaScript和Falsh进行交互。有了Canvas，我们就再也不需要Flash，直接使用JavaScript完成绘制。</p>
<p>一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">"test-stock"</span> width=<span class="string">"300"</span> height=<span class="string">"100"</span>&gt;</span><br><span class="line">    &lt;p&gt;sdfdf&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>canvas&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"test-stock"</span>);</span><br><span class="line">    <span class="keyword">var</span> cxt=c.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    cxt.fillStyle=<span class="string">"#FF0000"</span>;</span><br><span class="line">    cxt.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript使用id来寻找canvas元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"test-stock"</span>);</span><br></pre></td></tr></table></figure>

<p>然后，创建cantext对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cxt=c.getContext(<span class="string">"2d"</span>);</span><br></pre></td></tr></table></figure>

<p>getContext(“2d”)对象是内建的HTML5对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>
<p>而下面的两行长长的代码是绘制一个红色的矩形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cxt.fillStyle=<span class="string">"#FF0000"</span>;</span><br><span class="line">cxt.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);</span><br></pre></td></tr></table></figure>

<p>fillStyle方法将它变成红色，fillRect方法规定了形状、位置和尺寸。</p>
<hr>
<p><span style="font-size:30px">颜色、样式和阴影</span></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>fillStyle</code></td>
<td>设置或返回用于填充绘画的颜色、渐变或模式</td>
</tr>
<tr>
<td><code>strokeStyle</code></td>
<td>设置或返回用于笔触的颜色、渐变或模式</td>
</tr>
<tr>
<td><code>shadowColor</code></td>
<td>设置或返回用于阴影的颜色</td>
</tr>
<tr>
<td><code>shadowBlur</code></td>
<td>设置或返回用于阴影的模糊级别</td>
</tr>
<tr>
<td><code>shadowOffsetx</code></td>
<td>设置或返回阴影矩形状的水平距离</td>
</tr>
<tr>
<td><code>shadowOffsety</code></td>
<td>设置或返回阴影矩形状的垂直距离</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>createLinearGradient()</code></td>
<td>创建线性渐变(用在画布内容上)</td>
</tr>
<tr>
<td align="left"><code>createPattern()</code></td>
<td>在指定的方向上重复指定的元素</td>
</tr>
<tr>
<td align="left"><code>createRadialGradient()</code></td>
<td>创建放射状/环形的渐变(用在画布内容上)</td>
</tr>
<tr>
<td align="left"><code>addColorStop()</code></td>
<td>规定渐变对象中的颜色和停止位置</td>
</tr>
</tbody></table>
<hr>
<p><span style="font-size:30px">线条样式</span></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>lineCap</code></td>
<td>设置或返回线条的结束端点样式</td>
</tr>
<tr>
<td><code>lineJoin</code></td>
<td>设置或返回两条线相交时，所创建的拐角类型</td>
</tr>
<tr>
<td><code>lineWidth</code></td>
<td>设置或返回当前的线条宽度</td>
</tr>
<tr>
<td><code>miterLimit</code></td>
<td>设置或返回最大斜接长度</td>
</tr>
</tbody></table>
<p><span style="font-size:30px">矩形</span></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>recrt()</code></td>
<td>创建矩形</td>
</tr>
<tr>
<td><code>fillRect()</code></td>
<td>绘制“被填充”的矩形</td>
</tr>
<tr>
<td><code>strokeRect()</code></td>
<td>绘制矩形（无填充）</td>
</tr>
<tr>
<td><code>clearRect()</code></td>
<td>在给定的矩形内清楚指定的像素</td>
</tr>
</tbody></table>
<h5 id="理解坐标"><a href="#理解坐标" class="headerlink" title="理解坐标"></a>理解坐标</h5><p>刚刚上面fillRect方法拥有参数(0,0,150,75)。</p>
<p>意思是：在画布上绘制150x75的矩形，从左上角开始(0，0)。</p>
<p>看图，画布的x和y坐标用于在画布上对绘画进行定位。</p>
<p><img src="http://www.w3school.com.cn/i/ct_html5_canvas_coordinates.gif" alt="Canvas 实例：理解坐标"></p>
<h5 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h5><p>可以在Canvas上绘制各种形状。绘制前，需要先了解Canvas的坐标系统：</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001436926614788af8f274570d54736bddbbf7b2b03a9eb000/l" alt="canvas-xy"></p>
<p>Canvas的坐标比左上角为远点，水平向右为X轴，垂直向下为y轴，以像素为单位，所有每个点都是飞负整数。</p>
<p><span style="color:red"><code>CanvasRenderingContext2D</code></span>对象有若干方法来绘制图形：</p>
<h5 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h5><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：</p>
<p>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常浮躁的操作，考虑一下优化方案：</p>
<ul>
<li>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果赋值到页面的可见Canvas中；</li>
<li>尽量使用整数坐标而不是浮点数；</li>
<li>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</li>
<li>背景图片如果不变可以直接用<span style="color:red"><code>&lt;img&gt;</code></span>标签并放到最底层。</li>
</ul>
<h5 id="练习Canvas"><a href="#练习Canvas" class="headerlink" title="练习Canvas"></a>练习Canvas</h5><h6 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h6><p>通过指定的位置，到结束，绘制一条线：</p>
<p><img src="http://www.w3school.com.cn/i/ct_html5_canvas_line.gif" alt="Canvas 实例：线条"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">"test-stock"</span> width=<span class="string">"200"</span> height=<span class="string">"100"</span> style=<span class="string">"border:1px solid #c3c3c3;"</span>&gt;</span><br><span class="line">    Your browser does not support the canvas element.</span><br><span class="line">&lt;<span class="regexp">/canvas&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var c=document.getElementById("</span>test-stock<span class="string">");</span></span><br><span class="line"><span class="string">    var cxt=c.getContext("</span><span class="number">2</span>d<span class="string">");</span></span><br><span class="line"><span class="string">    cxt.moveTo(10,10);</span></span><br><span class="line"><span class="string">    cxt.lineTo(150,50);</span></span><br><span class="line"><span class="string">    cxt.lineTo(10,50);</span></span><br><span class="line"><span class="string">    cxt.stroke();</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">"test-stock"</span> width=<span class="string">"200"</span> height=<span class="string">"100"</span> style=<span class="string">"border:1px solid #c3c3c3;"</span>&gt;</span><br><span class="line">    Your browser does not support the canvas element.</span><br><span class="line">&lt;<span class="regexp">/canvas&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var c=document.getElementById("</span>test-stock<span class="string">");</span></span><br><span class="line"><span class="string">    var cxt=c.getContext("</span><span class="number">2</span>d<span class="string">");</span></span><br><span class="line">    cxt.fillStyle="#FF0000";</span><br><span class="line">    cxt.beginPath();</span><br><span class="line">    cxt.arc(<span class="number">70</span>,<span class="number">18</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">    cxt.closePath();</span><br><span class="line">    cxt.fill();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h6><p><img src="http://www.w3school.com.cn/i/ct_html5_canvas_gradient.gif" alt="Canvas 实例：渐变"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">"test-stock"</span> width=<span class="string">"200"</span> height=<span class="string">"100"</span> style=<span class="string">"border:1px solid #c3c3c3;"</span>&gt;</span><br><span class="line">    Your browser does not support the canvas element.</span><br><span class="line">&lt;<span class="regexp">/canvas&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var c=document.getElementById("</span>test-stock<span class="string">");</span></span><br><span class="line"><span class="string">    var cxt=c.getContext("</span><span class="number">2</span>d<span class="string">");</span></span><br><span class="line"><span class="string">    var grd=cxt.createLinearGradient(0,0,175,50);</span></span><br><span class="line">    grd.addColorStop(0,"#FF0000");</span><br><span class="line">    grd.addColorStop(<span class="number">1</span>,<span class="string">"#00FF00"</span>);</span><br><span class="line">    cxt.fillStyle=grd;</span><br><span class="line">    cxt.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">175</span>,<span class="number">50</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><p>江湖传言，全世界大约有80–90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所有每一个入门JavaScript的前端工程师都应该了解和学习它。</p>
<p>jQuery可以解决一些很重要的问题，它能帮我们：</p>
<ul>
<li>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</li>
<li>简洁的操作DOM的方法：写<span style="color:red"><code>$(&#39;#test&#39;)</code></span>肯定比<span style="color:red"><code>document.getElementById(&#39;test&#39;)</code></span>来得简洁；</li>
<li>轻松实现动画、修改CSS等各种操作。</li>
</ul>
<p>jQuery的理念“Write Less，Do More”，让你写更少的代码，完成更多的工作！</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>从jQuery官网可以下载最新版本。jQuery只是一个<span style="color:red"><code>jquery-xxx.js</code></span>文件，但你会看到有compressed(已压缩)和uncompressed(未压缩)两种版本，使用时完全一样，但如果你想深入研究jQuery源码，那就用uncompressed版本。</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul>
<li>ID选择器</li>
<li>类选择器</li>
<li>属性选择器</li>
<li>元素选择器</li>
<li>派生选择器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按ID查找&lt;div id="abc"&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'#abc'</span>);</span><br><span class="line"><span class="comment">//按类查找 &lt;p class="red"&gt;</span></span><br><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'red'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h4><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>浏览器在接收到用户的鼠标和键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。</p>
<p>由于不同的浏览器绑定事件的代码都不太一样，所有用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>
<p>假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个<code>click</code>事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *&lt;a id="test-link" href="#"&gt;点我试试&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取超链接的jQuery对象：</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'#test-link'</span>);</span><br><span class="line">a.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</section><nav id="post-nav"><span class="prev"></span><span class="next"><a href="/2019/06/21/虎丸toramaru/">Older Posts<span class="arrow">→</span></a></span></nav></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/fuzhouxxdong"><i class="fa fa-github"></i></a></div><p class="small">© Copyright 2018 &nbsp;<i class="fa fa-heart" aria-hidden="true">&nbsp;Dxx</i></p><p class="small">Powered by &nbsp;<a href="https://hexo.io/">Hexo &nbsp;</a>Theme By &nbsp;<a href="https://github.com/fuzhouxxdong/hexo-theme-dxx">Dxx</a></p></footer><script>hljs.initHighlightingOnLoad();</script></body></html>